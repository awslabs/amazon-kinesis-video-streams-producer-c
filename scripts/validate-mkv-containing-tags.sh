#!/bin/bash
set -e -u
set -o pipefail

# Given an MKV file generated by the SDK, that has fragment metadata for every fragment:
# 1. The Cluster is always followed by Tags
# 2. The Cluster comes first
# 3. Tag final group (containing "AWS_KINESISVIDEO_END_OF_FRAGMENT") has at least 2 tags.
#
# Otherwise, given an MKV file returned from KVS service:
# 1. There are 2 Tag groups
# 2. The service metadata tags come before the cluster
# 3. The user metadata tags come after the cluster
#
# Usage: ./validate-mkv-containing-tags.sh <MKV filePath>
#  - Must have mkvinfo (mkvtoolnix) installed

verify_mkvinfo_installed() {
  if ! command -v mkvinfo &>/dev/null; then
    echo "‚ùå Error: mkvinfo is not installed! Please install \`mkvtoolnix\`."
    exit 1
  fi
}

verify_mkv_file() {
  local file=$1

  if [[ ! -f "$file" ]]; then
    echo "‚ùå Error: \`$file\` not found!"
    exit 1
  fi

  if [[ ! -s "$file" ]]; then
    echo "‚ùå Error: \`$file\` is empty!"
    exit 1
  fi

  if ! mkvinfo -v "$file" &>/dev/null; then
    echo "‚ùå Error: $file is not a valid MKV file or cannot be parsed by \`mkvinfo\`."
    exit 1
  fi
}

detect_mkv_type() {
  local mkvinfo_output=$1

  local aws_count=$(echo "$mkvinfo_output" | grep -c "|   + Name: AWS_")
  local end_of_fragment_count=$(echo "$mkvinfo_output" | grep -c "|   + Name: AWS_KINESISVIDEO_END_OF_FRAGMENT")

  if [[ "$aws_count" -gt 0 && "$end_of_fragment_count" -eq 0 ]]; then
    echo "**MKV type:** persisted MKV"
  else
    echo "**MKV type:** SDK-generated MKV"
  fi
}

validate_at_least_one_cluster_exists() {
  local mkvinfo_output=$1
  local clusters=$(echo "$mkvinfo_output" | grep -c "|+ Cluster")

  if [[ "$clusters" -eq 0 ]]; then
    echo "‚ùå Error: There are no Clusters!"
    return 1
  fi
  echo "‚úÖ Contains Clusters (OK)"
  return 0
}

validate_at_least_one_tag_exists() {
  local mkvinfo_output=$1
  local tags=$(echo "$mkvinfo_output" | grep -c "|+ Tags")

  if [[ "$tags" -eq 0 ]]; then
    echo "‚ùå Error: There are no Tags!"
    return 1
  fi
  echo "‚úÖ Contains Tags (OK)"
  return 0
}

validate_clusters_followed_by_tags() {
  local mkvinfo_output=$1
  local clusters=$(echo "$mkvinfo_output" | grep -c "|+ Cluster")
  local clusters_followed_by_tags=$(echo "$mkvinfo_output" | grep -e "|+ Cluster" -e "|+ Tags" | tr '\n' ' ' | grep -o "|+ Cluster |+ Tags" | wc -l)

  if [[ "$clusters" -ne "$clusters_followed_by_tags" ]]; then
    echo "‚ùå Error: Not every Cluster is followed by a Tags section!"
    return 1
  fi
  echo "‚úÖ Every Cluster is followed by Tags (OK)"
  return 0
}

validate_clusters_come_first() {
  local mkvinfo_output=$1
  while IFS= read -r line; do
    if [[ "$line" == *"|+ Cluster"* ]]; then
      echo "‚úÖ Clusters detected first (OK)"
      return 0
    elif [[ "$line" == *"|+ Tags"* ]]; then
      echo "‚ùå Error: Tags appear before Clusters!"
      return 1
    fi
  done <<<"$mkvinfo_output"
  echo "‚ùå Error: No Clusters found! Invalid MKV structure?"
  return 1
}

validate_last_tag_group_has_two_tags() {
  local mkvinfo_output=$1

  local clusters_and_tags=$(echo "$mkvinfo_output" | grep -e "|+ Cluster" -e "|+ Tags")
  local last_element=$(echo "$clusters_and_tags" | tail -n1)

  if [[ "$last_element" != *"|+ Tags"* ]]; then
    echo "‚ùå Error: Last element is not Tags"
    return 1
  fi
  echo "‚úÖ Last element is Tags (OK)"

  local end_of_fragment_tags=$(echo "$mkvinfo_output" | grep -c "+ Name: AWS_KINESISVIDEO_END_OF_FRAGMENT")

  if [[ "$end_of_fragment_tags" -eq 0 ]]; then
    echo "‚ùå Error: Missing \`AWS_KINESISVIDEO_END_OF_FRAGMENT\`"
    return 1
  fi
  echo "‚úÖ Contains \`AWS_KINESISVIDEO_END_OF_FRAGMENT\` (OK)"

  local current_tag_count=0
  while IFS= read -r line; do
    if [[ "$line" == *"+ Name: AWS_KINESISVIDEO_END_OF_FRAGMENT"* ]]; then
      if [[ $current_tag_count -lt 2 ]]; then
        echo "‚ùå Error: Last tag group (containing AWS_KINESISVIDEO_END_OF_FRAGMENT) doesn't have at least two tags!"
        return 1
      fi
    elif [[ "$line" == *"|+ Tags"* ]]; then
      # Don't use ++ since it returns code 1 when var is 0
      current_tag_count=$((current_tag_count + 1))
    elif [[ "$line" == *"|+ Cluster"* ]]; then
      current_tag_count=0
    fi
  done <<<"$mkvinfo_output" | grep -e "|+ Cluster" -e "|+ Tags"
  echo "‚úÖ Last tags group has at least two Tags (OK)"
  return 0
}

validate_exactly_one_cluster() {
  local mkvinfo_output=$1
  local clusters=$(echo "$mkvinfo_output" | grep -c "|+ Cluster")

  if [[ "$clusters" -ne 1 ]]; then
    echo "‚ùå Error: There is more than 1 Cluster! (Are you sure this is persisted MKV?)"
    return 1
  fi
  echo "‚úÖ There is exactly 1 Cluster (OK)"
  return 0
}

validate_two_tag_groups() {
  local mkvinfo_output=$1
  local tags_before_clusters=$(echo "$mkvinfo_output" | grep -e "|+ Cluster" -e "|+ Tags" | tr '\n' ' ' | grep -o "|+ Tags |+ Cluster" | wc -l)
  local clusters_followed_by_tags=$(echo "$mkvinfo_output" | grep -e "|+ Cluster" -e "|+ Tags" | tr '\n' ' ' | grep -o "|+ Cluster |+ Tags" | wc -l)

  if [[ "$tags_before_clusters" -ne 1 ]]; then
    echo "‚ùå Error: Missing Tags before the Cluster!"
    return 1
  fi

  if [[ "$clusters_followed_by_tags" -ne 1 ]]; then
    echo "‚ùå Error: Missing Tags after the Cluster!"
    return 1
  fi

  echo "‚úÖ The Cluster is surrounded by Tags (OK)"
  return 0
}

validate_first_tag_group_is_aws_metadata() {
  local mkvinfo_output=$1
  local tags_before_cluster=$(echo "$mkvinfo_output" | grep -A 200 "|+ Tags" | grep -B 200 "|+ Cluster" | grep -e " + Name:")
  local aws_metadata_tags=$(echo "$tags_before_cluster" | grep -c "AWS_")
  local tags_before_cluster_count=$(echo "$tags_before_cluster" | wc -l)

  if [[ "$tags_before_cluster_count" -ne "$aws_metadata_tags" ]]; then
    echo "‚ùå Error: There are extra Tags before the Cluster!"
    return 1
  fi

  echo "‚úÖ The Cluster is has AWS metadata Tags before it (OK)"
  return 0
}

validate_last_tag_group_is_user_metadata() {
  local mkvinfo_output=$1
  local tags_after_cluster=$(echo "$mkvinfo_output" | grep -A 99999 "|+ Cluster" | grep -e " + Name:")
  local aws_metadata_tags=$(echo "$tags_after_cluster" | grep -c "AWS_")

  if [[ $(echo "$tags_after_cluster" | wc -l) -eq 0 ]]; then
    echo "‚ùå Error: There are no Tags after the Cluster!"
    return 1
  fi

  if [[ "$aws_metadata_tags" -ne 0 ]]; then
    echo "‚ùå Error: There are AWS metadata Tags after the Cluster!"
    return 1
  fi

  echo "‚úÖ Tags after the Cluster are user fragment metadata Tags (OK)"
  return 0
}

verify_file() {
  local file=$1

  echo "### MKV Structure Validation for $file üöÄ"
  verify_mkv_file "$file"

  local mkvinfo_output=$(mkvinfo -v "$file" 2>/dev/null)

  local mkv_type=$(detect_mkv_type "$mkvinfo_output")
  echo "$mkv_type"

  local error=0
  validate_at_least_one_cluster_exists "$mkvinfo_output" || error=1
  validate_at_least_one_tag_exists "$mkvinfo_output" || error=1
  validate_clusters_followed_by_tags "$mkvinfo_output" || error=1

  if [[ "$mkv_type" == "**MKV type:** SDK-generated MKV" ]]; then
    validate_clusters_come_first "$mkvinfo_output" || error=1
    validate_last_tag_group_has_two_tags "$mkvinfo_output" || error=1
  else
    validate_exactly_one_cluster "$mkvinfo_output" || error=1
    validate_two_tag_groups "$mkvinfo_output" || error=1
    validate_first_tag_group_is_aws_metadata "$mkvinfo_output" || error=1
    validate_last_tag_group_is_user_metadata "$mkvinfo_output" || error=1
  fi

  if [[ $error -ne 0 ]]; then
    echo "#### ‚ùå MKV validation failed for $file"
    echo ""
    echo "<details>"
    echo "<summary>$file</summary>"
    echo ""
    echo "\`\`\`"
    echo "$mkvinfo_output"
    echo "\`\`\`"
    echo ""
    echo "</details>"
  else
    echo "#### ‚úÖ MKV validation succeeded for $file"
  fi

  return $error
}

main() {
  if [[ "$#" -lt 1 || "$@" == "-h" || "$@" == "--help" ]]; then
    echo "Amazon KVS MKV Fragment Metadata Validator"
    echo "Validates MKVs containing fragment metadata generated by the KVS Producer SDK, or a fragment downloaded from KVS"
    echo "Outputs a report in Markdown"
    echo ""
    echo "Usage: $0 <file1> [file2] [file3] ..."
    exit 1
  fi

  verify_mkvinfo_installed

  local overall_error=0
  for file_name in "$@"; do
    verify_file "$file_name" || overall_error=1
    echo ""
  done

  exit $overall_error
}

main "$@"
